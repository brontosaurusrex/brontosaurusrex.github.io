I"§m<h2 id="no-file-for-you">No file for you</h2>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>[[ -f /var/log/apt/history.log ]] || exit 1
</code></pre></div></div>

<p>Will exit if file is not there, same thing should be used if you use cd in your scripts
Note: Actually just using ‚Äòexit‚Äô should be enough, as it returns the status value of previous command (exit equals to exit $?).</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>cd /some/path || exit 1
</code></pre></div></div>

<p>Or do it on a more global level with</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>set -e # script will from now on exit on 1st error
</code></pre></div></div>

<p>This will ensure that script doesn‚Äôt continue if dir doesn‚Äôt exist. Another way might be:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>config="$HOME/bin/singularity.cfg"
test -f "$config" &amp;&amp; source "$config" &gt;/dev/null || { echo "$config does not exist" ; exit 1; }
</code></pre></div></div>

<p>Do something if directory is there</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>[[ -d $HOME/apps/blender ]] &amp;&amp; mv "$HOME/apps/blender" "$HOME/apps/blender_bak_$RANDOM"
</code></pre></div></div>

<p>With if</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>file="$HOME/.pcalc.txt"
if [ -f "$file" ]; then
    tail -n 100 "$file" &gt; "$file.tmp" &amp;&amp; mv "$file.tmp" "$file"
fi
</code></pre></div></div>

<p>Note that -e would be any file/dir/socket/node, -d is dir and so on</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>-b filename - Block special file
-c filename - Special character file
-d directoryname - Check for directory Existence
-e filename - Check for file existence, regardless of type (node, directory, socket, etc.)
-f filename - Check for regular file existence not a directory
-G filename - Check if file exists and is owned by effective group ID
-G filename set-group-id - True if file exists and is set-group-id
-k filename - Sticky bit
-L filename - Symbolic link
-O filename - True if file exists and is owned by the effective user id
-r filename - Check if file is a readable
-S filename - Check if file is socket
-s filename - Check if file is nonzero size
-u filename - Check if file set-user-id bit is set
-w filename - Check if file is writable
-x filename - Check if file is executable
</code></pre></div></div>

<h2 id="mkdir">mkdir</h2>

<p>Only if one is not already there, should also be recursive</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>mkdir -p ~/tmp/stuff
</code></pre></div></div>

<h2 id="exit-if-var-is-empty">Exit if var is empty</h2>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>[[ -z "$url" ]] &amp;&amp; (echo "no url for you" &amp;&amp; exit 1)
</code></pre></div></div>

<h2 id="benchmark-script">Benchmark script</h2>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>time for i in $(seq 1000); do script; done
</code></pre></div></div>

<p>They say this is bad due to IO (disk) reads.</p>

<h2 id="remove-numerals-and-fill-some-variables">Remove numerals and fill some variables</h2>
<p>echo ‚ÄúUh oh. Something went really bad..‚Äù &gt;&amp;2
    stuff=‚Äù1680x1050+2880+23‚Äù
    read -r h w x y ¬´&lt; $(echo ${stuff//[!0-9]/ })</p>

<p>2nd part is called <em>special parameter expansion replacing non-numeric characters with space</em>.</p>

<h2 id="random-word">Random word</h2>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>randomword()  {
    dict="/usr/share/dict/words"
    if [ -f "$dict" ]; then
        word=$(shuf -n1 "$dict" | tr -dc '[:alnum:]\n\r' | tr '[:upper:]' '[:lower:]')
        # if dict gets us null length then replace with something else
        [ -z "$word" ] &amp;&amp; word="$RANDOM"
    else # there is no dict file
        word="$RANDOM"
    fi
    echo "$word"
}
word=$(randomword)
</code></pre></div></div>

<h2 id="checks-critical-and-non-critical">Checks critical and non-critical</h2>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>command -v mediainfo &gt;/dev/null 2&gt;&amp;1 || { &gt;&amp;2 echo "I need mediainfo installed." ; exit 1; }
command -v mediainfo &gt;/dev/null 2&gt;&amp;1 || { &gt;&amp;2 echo "I'd like mediainfo installed." ; }
</code></pre></div></div>

<h2 id="dirs-and-files-and-paths-breakdown">Dirs and files and paths breakdown</h2>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>file=$(readlink -f "$1")       # quasi absolute
baseext=$(basename "${1}")     # or
baseext=${i##*/}               # file.ext
base="${baseext%.*}"           # file
ext="${file##*.}"              # ext
dir=$(dirname "${file}")       # or
dir=${i%/*}                    # directory
</code></pre></div></div>

<p><a href="http://mywiki.wooledge.org/BashFAQ/073">http://mywiki.wooledge.org/BashFAQ/073</a></p>

<h2 id="dump-stuff-from-web-pages">Dump stuff from web pages</h2>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>read -r _ temp _&lt;&lt;&lt; $(lynx -dump http://some/link.htm | grep Cityname) &amp;&amp; echo "$temp¬∞C"
</code></pre></div></div>

<p>Lynx may be a fat solution, but it‚Äôs an easy one.</p>

<p>Another interesting option is combo of wget and xml2/html2</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>wget http://some/link.htm -O - -o /dev/null | html2 | #more filtering
</code></pre></div></div>

<h2 id="grep-and">grep AND</h2>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>lynx -listonly -nonumbers -dump https://builder.blender.org/download/ | grep "$bits" | grep linux | grep https | grep tar | head -1
</code></pre></div></div>

<p>Such grep sequence will behave as logical AND, there are other shorter ways.</p>

<h2 id="check-for-certain-extensions-yourself">Check for certain extensions yourself</h2>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code># do I need this
shopt -s extglob
# If no specific arguments were passed to script then it will check current dir for certain audio extensions itself
(( $# )) || set -- *.@(mp3|mp4|m4a|flac|ogg|mpc|wav|aif|opus); [[ -e $1 ]] || \
{ echo "No audio files find in this dir (mp3|mp4|m4a|flac|ogg|mpc|wav|aif|opus)"; stty sane; exit 1; }
</code></pre></div></div>

<h2 id="rounding-math">Rounding math</h2>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code># awk_round

awk_round () {
    awk 'BEGIN{printf "%."'$1'"f\n", "'$2'"}'
}

awk_round "$1" "$2"
</code></pre></div></div>

<p><a href="https://brontosaurusrex.github.io/2017/06/10/bash-rounding-n-th-time/">https://brontosaurusrex.github.io/2017/06/10/bash-rounding-n-th-time/</a></p>

<p>The idea is you can do all your floating math using bc, but this will give you final rounding that one would somehow expect.</p>

<h2 id="awk-calc-function">awk calc function</h2>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>calca() #@ Perform arithmetic, including decimal fractions
{
local result=$(awk 'BEGIN { OFMT="%f"; print '"$*"'; exit}')
case $result in
*.*0) result=${result%"${result##*[!0]}"} ;;
esac
printf "%s\n" "$result"
}

calca 1/3
</code></pre></div></div>

<blockquote>
  <p>that characters special to the shell must be escaped or quoted on the
command line. This applies particularly to the multiplication symbol, *.</p>
</blockquote>

<p>From the book: Pro Bash Programming</p>

<p><em>Not battle-tested, not benchmarked.</em></p>

<h2 id="bc-calc-function">bc calc function</h2>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>calc () {
    echo "scale=5; $*" | bc
}

calc 1/2
</code></pre></div></div>

<p><em>Not battle-tested</em></p>

<p>or prettier,</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>calc2 () {
     bc &lt;&lt;&lt; "scale=5; $*"
}
</code></pre></div></div>

<p>but slower than echo/pipe version above. That triple &lt; is called here-string.</p>

<h2 id="add-path-and-modify-env">Add path and modify env</h2>

<p>This may be usefull to add to scripts that are run from cron</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>PATH="/home/ticho/bin/":$PATH
export LC_ALL=en_US.UTF-8
</code></pre></div></div>

<p>or one could run firefox with a different theme</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>GTK_THEME=Adapta launchee firefox
</code></pre></div></div>

<p>see what‚Äôs out there</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>env
echo $PATH
</code></pre></div></div>

<h2 id="tmpdir">tmpdir</h2>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code># tmp dir http://mywiki.wooledge.org/BashFAQ/062
tmp="/tmp/$RANDOM-$$"
trap '[ -n "$tmp" ] &amp;&amp; rm -fr "$tmp"' EXIT
mkdir -m 700 "$tmp" || { echo '!! unable to create a tmpdir' &gt;&amp;2; tmp=; exit 1; }
</code></pre></div></div>

<h2 id="tmpdir-with-more-advanced-trap-calling-function">tmpdir with more advanced trap calling function</h2>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>cleanup () {
(( debug )) &amp;&amp; echo "$?"
[ -n "$tmp" ] &amp;&amp; rm -fr "$tmp"
tput cnorm
}

# tmp dir
tmp="/tmp/$RANDOM-$$"
trap cleanup EXIT SIGTERM SIGINT 
# https://www.gnu.org/software/libc/manual/html_node/Termination-Signals.html
mkdir -m 700 "$tmp" || { echo '!! unable to create a tmp dir' &gt;&amp;2; tmp=; exit 1; }
</code></pre></div></div>

<h2 id="i-did-something-audio">I did something audio</h2>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>flite -voice rms "I did something" &gt;/dev/null 2&gt;&amp;1
</code></pre></div></div>

<h2 id="isnumber-function">isNumber function</h2>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code># function
shopt -s extglob
isNumber() {
var="$1"
# Àá will fail for numbers like 4.044676226059745e-17 (so called scientific notation)
if [[ $var = @(*[0-9]*|!([+-]|)) &amp;&amp; $var = ?([+-])*([0-9])?(.*([0-9])) ]]; then
  #echo "fine"
  ans="$var"
  true  # return 0
else
  #echo "bad"
  ans="0"
  false # return 1
fi
}
</code></pre></div></div>

<p>examples</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>ans="33.3"
if isNumber "$ans"; then # do something
ans="a"
isNumber "$ans"          # $ans will be 0 if not a number
</code></pre></div></div>

<h2 id="timer-benchmark">Timer (benchmark)</h2>

<p>This is useful for timing parts of the script</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code># benchmark start
START=$(date +%s.%N)

# your script here

# benchmark end
END=$(date +%s.%N)
DIFF=$(echo "$END - $START" | bc)
echo "done in $DIFF seconds"
</code></pre></div></div>

<p>for whole thing one could run script as</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>time script
</code></pre></div></div>

<h2 id="try-until-it-works">Try until it works</h2>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>play() {
    /usr/bin/mpv https://stream/chunklist.m3u8 --no-resume-playback
}

until play
do
  sleep 60
done
</code></pre></div></div>

<p>Also works nicely interactively</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>until latoya ; do sleep 30 ; done
</code></pre></div></div>

<h2 id="bool-if">Bool ‚Äòif‚Äô</h2>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>value="1"
((value)) &amp;&amp; echo "is true"
</code></pre></div></div>

<h2 id="command-in-variable-is-a-no">Command in variable is a NO</h2>
<p><a href="http://mywiki.wooledge.org/BashFAQ/050">http://mywiki.wooledge.org/BashFAQ/050</a></p>

<blockquote>
  <p>A simple variable string wouldn‚Äôt work because no other ‚Äúexpansions‚Äù happen after word splitting, and that includes recognition of keywords and control operators. Keywords and control operators expanded after word splitting are considered to be just ordinary arguments, and not part of the syntax</p>
</blockquote>

<h2 id="arrays">Arrays</h2>

<h3 id="quasi-multidimensional-array">Quasi multidimensional array</h3>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>#!/bin/bash

# 1D array with 'one,two,three' fields
data=(
one,two,three
four,five,six
seven,eight,nine
)

# actualy each line is a single field of array,
# but we can break the lines with a fancy loop:

while read -r line; do
    IFS=, read -r app config method &lt;&lt;&lt; "$line"

    echo "$app $config $method"

done &lt; &lt;(printf '%s\n' "${data[@]}")
</code></pre></div></div>

<h3 id="associative-array-expansion">Associative array expansion?</h3>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>#!/bin/bash

# an array here
declare -A exe
exe=(
["serverOne"]="echo woot" 
["job"]="sleep 3" 
["myserv"]="neofetch" 
)

# this is the exe
${exe[serverOne]} 
${exe[job]} 
${exe[myserv]}
</code></pre></div></div>

<h2 id="-brackets---test">[[ brackets ]] = Test</h2>

<p>(http://mywiki.wooledge.org/BashFAQ/031)[http://mywiki.wooledge.org/BashFAQ/031]</p>

<p>Are used for testing stuff, for example string comparision and it‚Äôs smarter brother of single [.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>[[ a &gt; b ]] || echo "a does not come after b"
</code></pre></div></div>

<h2 id="-brackets---subshell">( brackets ) = Subshell</h2>

<blockquote>
  <p>Subshell is similar to child, but more info is inherited.</p>
</blockquote>

<p>(cd /tmp || exit 1; date &gt; timestamp)
pwd</p>

<p>Cd to /tmp folder is internal to only that subshell. Also if cd would fail, it would only terminate that specific subshell and not the main process.</p>

<h2 id="-brackets---command-grouping">{ brackets; } = Command grouping</h2>

<p>Generally speaking last command must be terminated with ;, unless } is at the start of line</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>{   echo "app, config, restart method"
    echo "---, ------, --------------"
    while read -r line; do
        IFS=, read -r app config method &lt;&lt;&lt; "$line"

        
        echo "$app, $config, $method" 
        
      
    done &lt; &lt;(printf '%s\n' "${configs[@]}")
} | column -s, -t
</code></pre></div></div>

<p>When at the end, use ;</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>[[ -f $file ]] || { echo "$file not found"; exit 1; }
</code></pre></div></div>

<h2 id="-and--brackets--process-substitution">&lt;() and ()&gt; brackets = Process Substitution</h2>

<blockquote>
  <p>A cousin of the pipe is the process substitution operator, which comes in two forms: &lt;() and &gt;(). It‚Äôs a convenient way to use named pipes without having to create temporary files. Whenever you think you need a temporary file to do something,
process substitution might be a better way to handle things.
What it does, is basically run the command inside the parentheses. With the &lt;() operator, the command‚Äôs output is put in a something similar to named pipe.</p>
</blockquote>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code># diff -y &lt;(head -n 1 .dictionary) &lt;(tail -n 1 .dictionary)
</code></pre></div></div>

<p>Basically diff will see two files.</p>

<h2 id="-brackets---arithmetic-evaluation">(( brackets )) = Arithmetic evaluation</h2>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>(( 2 == 2 )) &amp;&amp; echo true
echo $(( 2 + 2 ))
echo "There are $(($rows * $columns)) cells"
</code></pre></div></div>

<p>Roll dice alias</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>alias dice='echo $(( RANDOM % 6 + 1 ))'
</code></pre></div></div>

<h2 id="redirects">Redirects</h2>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>ls &gt; file.log 2&gt;&amp;1
</code></pre></div></div>

<p>should write both stdout and stderr to file.log.</p>

<h3 id="cron-example-where-stdout-and-stderr-are-separated-into-two-files">Cron example where stdout and stderr are separated into two files</h3>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>0 0 * * * bin/dropbox start &gt;/tmp/dbstdout.log 2&gt;/tmp/dbstderr.log
</code></pre></div></div>

<h3 id="stdout-to-null">Stdout to null</h3>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>ls &gt;/dev/null  # same with space: ls &gt; /dev/null
</code></pre></div></div>

<h3 id="stderr-to-null">Stderr to null</h3>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>ls 2&gt;/dev/null # same with space: ls 2&gt; /dev/null
</code></pre></div></div>

<h3 id="stdout-and-stderr-to-null">Stdout and stderr to null</h3>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>ls &gt;/dev/null 2&gt;&amp;1
# same with space: ls &gt; /dev/null 2&gt;&amp;1
</code></pre></div></div>

<h2 id="sourcing">Sourcing</h2>

<p>Imagine a script named ‚Äòwoot‚Äô</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>#!/bin/bash
cd /tmp
</code></pre></div></div>

<p>If I ./woot, nothing will change (pwd will stay the same), however if I</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>. ./woot      # dotting
#or
source ./woot
</code></pre></div></div>

<p>pwd will change.</p>

<p>if woot is somewhere on $PATH, this will also work</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>. woot
</code></pre></div></div>

<h2 id="find-and-xz-pack">Find and xz pack</h2>

<p>All in this dir, including hidden files</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>find . -type f -exec xz {} +   # pack file by file
find . -type f -exec unxz {} + # unpack file by file
</code></pre></div></div>

<p>xz entire dir as single file (staring from one dir above)</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code> tar -cf- dir | xz &gt; roboto.tar.xz
</code></pre></div></div>

<h2 id="do-it-maybe">Do it maybe</h2>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>rotateMaybe () {
if (( RANDOM %2 )) ; then
    mogrify -rotate 180 "$final"
    printf "r"
else
    printf "n"
fi
}
</code></pre></div></div>

<h2 id="restart-something">Restart something</h2>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>restart() {
if pgrep -x "$1" &gt; /dev/null
then
    (echo "$1 running, restarting"
    killall -w "$1"
    "${1}" &amp;) &amp;
else
    echo "$1 wasn't running"
fi
}

restart wbar
</code></pre></div></div>

<h2 id="center-text">Center text</h2>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>centertext(){
    columns=$(tput cols) 
    string="$1" 
    printf "%*s\n" $(((${#string}+columns)/2)) "$string"
}

centertext "woot"
</code></pre></div></div>

<h2 id="printf-examples">printf examples</h2>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code># round float
a=3.123456
printf "%.2f\n" "a"         
3.12
printf "%.4f\n" "a"
3.1235

# type protection ?
a="1"
printf "%d\n" "a"
1
a="b"
printf "%d\n" "a"
0
</code></pre></div></div>

<h2 id="inline-block-of-text-to-variable">Inline block of text to variable</h2>

<p>This is not compatible with ‚Äòset -e‚Äô</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code># custom css
css=$(cat &lt;&lt;'CSS'
&lt;style type="text/css"&gt;
    p       { margin-top: 0; margin-bottom: 0; vertical-align: top; font-family: 'Noto Serif', serif; font-size: large }
    a       { font-family: 'Noto Serif', serif; font-size: large }
    pre     { margin-top: 0; margin-bottom: 0; vertical-align: top; font-size: large }
&lt;/style&gt;''
CSS
)
echo "$css"
</code></pre></div></div>

<h2 id="bash-literature">Bash literature</h2>

<h3 id="httpsmywikiwooledgeorgbashguide"><a href="https://mywiki.wooledge.org/BashGuide">https://mywiki.wooledge.org/BashGuide</a></h3>
<p>They also have a pdf version.</p>

<h3 id="httpsgithubcomdylanarapspure-bash-bible"><a href="https://github.com/dylanaraps/pure-bash-bible">https://github.com/dylanaraps/pure-bash-bible</a></h3>
<p><em>A collection of pure POSIX sh alternatives to external processes</em></p>

<h3 id="httpshnalgoliacomqbash"><a href="https://hn.algolia.com/?q=bash">https://hn.algolia.com/?q=bash</a></h3>
<p>Search for ‚Äòbash‚Äô in hacker news.</p>

<h3 id="pure-bash-bible"><a href="https://github.com/dylanaraps/pure-bash-bible">pure bash bible</a></h3>
<p>A collection of pure bash alternatives to external processes.</p>

<h2 class="no_toc" id="index">Index</h2>

<ul id="markdown-toc">
  <li><a href="#no-file-for-you" id="markdown-toc-no-file-for-you">No file for you</a></li>
  <li><a href="#mkdir" id="markdown-toc-mkdir">mkdir</a></li>
  <li><a href="#exit-if-var-is-empty" id="markdown-toc-exit-if-var-is-empty">Exit if var is empty</a></li>
  <li><a href="#benchmark-script" id="markdown-toc-benchmark-script">Benchmark script</a></li>
  <li><a href="#remove-numerals-and-fill-some-variables" id="markdown-toc-remove-numerals-and-fill-some-variables">Remove numerals and fill some variables</a></li>
  <li><a href="#random-word" id="markdown-toc-random-word">Random word</a></li>
  <li><a href="#checks-critical-and-non-critical" id="markdown-toc-checks-critical-and-non-critical">Checks critical and non-critical</a></li>
  <li><a href="#dirs-and-files-and-paths-breakdown" id="markdown-toc-dirs-and-files-and-paths-breakdown">Dirs and files and paths breakdown</a></li>
  <li><a href="#dump-stuff-from-web-pages" id="markdown-toc-dump-stuff-from-web-pages">Dump stuff from web pages</a></li>
  <li><a href="#grep-and" id="markdown-toc-grep-and">grep AND</a></li>
  <li><a href="#check-for-certain-extensions-yourself" id="markdown-toc-check-for-certain-extensions-yourself">Check for certain extensions yourself</a></li>
  <li><a href="#rounding-math" id="markdown-toc-rounding-math">Rounding math</a></li>
  <li><a href="#awk-calc-function" id="markdown-toc-awk-calc-function">awk calc function</a></li>
  <li><a href="#bc-calc-function" id="markdown-toc-bc-calc-function">bc calc function</a></li>
  <li><a href="#add-path-and-modify-env" id="markdown-toc-add-path-and-modify-env">Add path and modify env</a></li>
  <li><a href="#tmpdir" id="markdown-toc-tmpdir">tmpdir</a></li>
  <li><a href="#tmpdir-with-more-advanced-trap-calling-function" id="markdown-toc-tmpdir-with-more-advanced-trap-calling-function">tmpdir with more advanced trap calling function</a></li>
  <li><a href="#i-did-something-audio" id="markdown-toc-i-did-something-audio">I did something audio</a></li>
  <li><a href="#isnumber-function" id="markdown-toc-isnumber-function">isNumber function</a></li>
  <li><a href="#timer-benchmark" id="markdown-toc-timer-benchmark">Timer (benchmark)</a></li>
  <li><a href="#try-until-it-works" id="markdown-toc-try-until-it-works">Try until it works</a></li>
  <li><a href="#bool-if" id="markdown-toc-bool-if">Bool ‚Äòif‚Äô</a></li>
  <li><a href="#command-in-variable-is-a-no" id="markdown-toc-command-in-variable-is-a-no">Command in variable is a NO</a></li>
  <li><a href="#arrays" id="markdown-toc-arrays">Arrays</a>    <ul>
      <li><a href="#quasi-multidimensional-array" id="markdown-toc-quasi-multidimensional-array">Quasi multidimensional array</a></li>
      <li><a href="#associative-array-expansion" id="markdown-toc-associative-array-expansion">Associative array expansion?</a></li>
    </ul>
  </li>
  <li><a href="#-brackets---test" id="markdown-toc--brackets---test">[[ brackets ]] = Test</a></li>
  <li><a href="#-brackets---subshell" id="markdown-toc--brackets---subshell">( brackets ) = Subshell</a></li>
  <li><a href="#-brackets---command-grouping" id="markdown-toc--brackets---command-grouping">{ brackets; } = Command grouping</a></li>
  <li><a href="#-and--brackets--process-substitution" id="markdown-toc--and--brackets--process-substitution">&lt;() and ()&gt; brackets = Process Substitution</a></li>
  <li><a href="#-brackets---arithmetic-evaluation" id="markdown-toc--brackets---arithmetic-evaluation">(( brackets )) = Arithmetic evaluation</a></li>
  <li><a href="#redirects" id="markdown-toc-redirects">Redirects</a>    <ul>
      <li><a href="#cron-example-where-stdout-and-stderr-are-separated-into-two-files" id="markdown-toc-cron-example-where-stdout-and-stderr-are-separated-into-two-files">Cron example where stdout and stderr are separated into two files</a></li>
      <li><a href="#stdout-to-null" id="markdown-toc-stdout-to-null">Stdout to null</a></li>
      <li><a href="#stderr-to-null" id="markdown-toc-stderr-to-null">Stderr to null</a></li>
      <li><a href="#stdout-and-stderr-to-null" id="markdown-toc-stdout-and-stderr-to-null">Stdout and stderr to null</a></li>
    </ul>
  </li>
  <li><a href="#sourcing" id="markdown-toc-sourcing">Sourcing</a></li>
  <li><a href="#find-and-xz-pack" id="markdown-toc-find-and-xz-pack">Find and xz pack</a></li>
  <li><a href="#do-it-maybe" id="markdown-toc-do-it-maybe">Do it maybe</a></li>
  <li><a href="#restart-something" id="markdown-toc-restart-something">Restart something</a></li>
  <li><a href="#center-text" id="markdown-toc-center-text">Center text</a></li>
  <li><a href="#printf-examples" id="markdown-toc-printf-examples">printf examples</a></li>
  <li><a href="#inline-block-of-text-to-variable" id="markdown-toc-inline-block-of-text-to-variable">Inline block of text to variable</a></li>
  <li><a href="#bash-literature" id="markdown-toc-bash-literature">Bash literature</a>    <ul>
      <li><a href="#httpsmywikiwooledgeorgbashguide" id="markdown-toc-httpsmywikiwooledgeorgbashguide">https://mywiki.wooledge.org/BashGuide</a></li>
      <li><a href="#httpsgithubcomdylanarapspure-bash-bible" id="markdown-toc-httpsgithubcomdylanarapspure-bash-bible">https://github.com/dylanaraps/pure-bash-bible</a></li>
      <li><a href="#httpshnalgoliacomqbash" id="markdown-toc-httpshnalgoliacomqbash">https://hn.algolia.com/?q=bash</a></li>
      <li><a href="#pure-bash-bible" id="markdown-toc-pure-bash-bible">pure bash bible</a></li>
    </ul>
  </li>
</ul>
:ET